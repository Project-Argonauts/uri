//-----------------------------------------------------------------------------------------
/*
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
░        ░░░░░░░░░░░░░░░░░░░░░░░░░░░   ░░░░░░░   ░
▒   ▒▒▒▒▒▒▒▒  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  ▒▒▒▒▒  ▒   ▒▒▒    ▒▒▒▒▒   ▒▒▒▒
▒   ▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒   ▒▒   ▒▒   ▒▒   ▒   ▒ ▒   ▒▒▒▒▒   ▒▒▒▒
▓       ▓▓▓   ▓▓▓  ▓   ▓▓   ▓▓▓▓▓  ▓   ▓▓   ▓▓   ▓▓▓▓▓   ▓▓▓▓
▓   ▓▓▓▓▓▓▓   ▓▓▓▓  ▓▓▓▓▓▓▓   ▓  ▓▓▓   ▓▓▓  ▓▓   ▓▓▓▓▓   ▓▓▓▓
▓   ▓▓▓▓▓▓▓   ▓▓  ▓▓   ▓▓   ▓▓▓▓   ▓   ▓▓▓▓▓▓▓   ▓▓▓▓▓   ▓▓▓▓
█   ███████   █   ███   ███     ████   ███████   █████   ████
█████████████████████████████████████████████████████████████
*/
//
// uri (header only)
// Copyright (C) 2024 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/uri
//
// Lightweight header-only C++20 URI parser
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#ifndef FIX8_URI_HPP_
#define FIX8_URI_HPP_

//----------------------------------------------------------------------------------------
#include <iostream>
#include <iomanip>
#include <type_traits>
#include <array>
#include <string>
#include <string_view>
#include <stdexcept>
#include <utility>
#include <cstdint>
#include <bit>

//-----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
using query_pair = std::pair<std::string_view, std::string_view>;
using query_result = std::vector<query_pair>;

//-----------------------------------------------------------------------------------------
class basic_uri
{
public:
	using uri_len_t = std::uint16_t;
	enum component : uri_len_t { scheme, authority, user, password, host, port, path, query, fragment, countof };
private:
	std::string_view _source;
	std::array<std::pair<uri_len_t, uri_len_t>, component::countof> _ranges;
	uri_len_t _present{};
	constexpr void set(component what) noexcept { _present |= (1 << what); }
	constexpr void clear(component what) noexcept { _present &= ~(1 << what); }
	static constexpr const std::array component_names { "scheme", "authority", "user", "password", "host", "port", "path", "query", "fragment", };
	static constexpr bool is_ipv6(std::string_view what) noexcept { return what.front() == '[' && what.back() == ']'; }
public:
	constexpr basic_uri(std::string_view src) : _source(src) { parse(); }
	constexpr basic_uri() = default;
	~basic_uri() = default;

	constexpr int assign(std::string_view src)
	{
		_source = src;
		_present = 0;
		return parse();
	}
	constexpr std::string_view get_source() const noexcept { return _source; }
	constexpr std::string_view get_component(component what) const
	{
		if (what < countof)
			return test(what) ? _source.substr(_ranges[what].first, _ranges[what].second) : std::string_view();
		throw(std::out_of_range("invalid component index"));
	}
	constexpr query_pair get_named_pair(component what) const
	{
		if (what < countof)
			return test(what) ? std::make_pair(component_names[what], _source.substr(_ranges[what].first, _ranges[what].second))
									: std::make_pair(std::string_view(), std::string_view());
		throw(std::out_of_range("invalid component index"));
	}
	constexpr int count() const noexcept { return std::popcount(_present); } // upgrade to std::bitset when constexpr in c++23
	constexpr bool test(component what) const noexcept { return _present & (1 << what); }

	constexpr int parse()
	{
		if (_source.empty())
			return 0;
		if (_source.size() > UINT16_MAX)
			throw(std::out_of_range("uri too long"));
		if (_source.find_first_of("\t\r\n ") != std::string_view::npos)
			throw(std::logic_error("invalid uri"));
		std::string_view::size_type pos{}, hst{}, pth{std::string_view::npos};
		if (auto sch {_source.find_first_of(':')}; sch != std::string_view::npos)
		{
			_ranges[scheme] = std::make_pair(0, sch);
			set(scheme);
			pos = sch + 1;
		}
		if (auto auth {_source.find_first_of("//", pos)}; auth != std::string_view::npos)
		{
			auth += 2;
			if ((pth = _source.find_first_of('/', auth)) == std::string_view::npos) // unterminated path
				pth = _source.size();
			_ranges[authority] = std::make_pair(auth, pth - auth);
			set(authority);
			if (const auto usr {_source.find_first_of('@', auth)}; usr != std::string_view::npos && usr < pth)
			{
				if (const auto pw {_source.find_first_of(':', auth)}; pw != std::string_view::npos && pw < usr
					&& _source.find_first_of(':', pw + 1) == std::string_view::npos) // no nested ':' before '@'
				{
					_ranges[user] = std::make_pair(auth, pw - auth);
					_ranges[password] = std::make_pair(pw + 1, usr - pw - 1);
					set(password);
				}
				else
					_ranges[user] = std::make_pair(auth, usr - auth);
				set(user);
				hst = pos = usr + 1;
			}
			else
				hst = pos = auth;

			if (auto prt { _source.find_first_of(':', pos) }; prt != std::string_view::npos
				&& !is_ipv6(get_component(authority)))
			{
				++prt;
				if (_source.size() - prt > 0)
				{
					_ranges[port] = std::make_pair(prt, _source.size() - prt);
					set(port);
				}
			}
		}
		if (pth != std::string_view::npos)
		{
			if (test(port))
			{
				if (pth - _ranges[port].first == 0) // remove empty port
					clear(port);
				else
					_ranges[port].second = pth - _ranges[port].first;
				_ranges[host] = std::make_pair(hst, _ranges[port].first - 1 - hst);
			}
			else
				_ranges[host] = std::make_pair(hst, pth - hst);
			if (_ranges[host].second)
				set(host);
			_ranges[path] = std::make_pair(pth, _source.size() - pth);
			set(path);
		}
		if (pth == std::string_view::npos)
		{
			_ranges[path] = std::make_pair(pos, _source.size() - pos);
			set(path);
		}
		if (const auto qur {_source.find_first_of('?', pos)}; qur != std::string_view::npos)
		{
			if (test(path))
				_ranges[path].second = qur - _ranges[path].first;
			_ranges[query] = std::make_pair(qur + 1, _source.size() - qur);
			set(query);
		}
		if (const auto fra {_source.find_first_of('#', pos)}; fra != std::string_view::npos)
		{
			if (test(query))
				_ranges[query].second = fra - _ranges[query].first;
			_ranges[fragment] = std::make_pair(fra + 1, _source.size() - fra);
			set(fragment);
		}
		return count();
	}
	constexpr query_result decode_query() const
	{
		constexpr auto decpair([](std::string_view src)->query_pair
		{
			if (auto fnd { src.find_first_of('=') }; fnd != std::string::npos)
				return {src.substr(0, fnd), src.substr(fnd + 1)};
			else if (src.size())
				return {src, ""};
			return {};
		});
		query_result result;
		if (std::string_view src{get_component(query)}; !src.empty())
		{
			for (std::string::size_type pos{};;)
			{
				if (auto fnd { src.find_first_of('&', pos) }; fnd != std::string::npos)
				{
					result.emplace_back(decpair(src.substr(pos, fnd - pos)));
					pos = fnd + 1;
					continue;
				}
				if (pos < src.size())
					result.emplace_back(decpair(src.substr(pos, src.size() - pos)));
				break;
			}
		}
		return result;
	}

	static constexpr std::string_view::size_type find_hex(std::string_view src) noexcept
	{
		for (std::string_view::size_type fnd{}; ((fnd = src.find_first_of('%', fnd))) != std::string_view::npos; fnd += 3)
			if (fnd + 2 < src.size() && std::isxdigit(src[fnd + 1]) && std::isxdigit(src[fnd + 2]))
				return fnd;
		return std::string_view::npos;
	}
	static constexpr bool has_hex(std::string_view src) noexcept { return find_hex(src) != std::string_view::npos; }
	static constexpr std::string decode_hex(std::string_view src)
	{
		std::string result{src};
		for (std::string_view::size_type fnd; ((fnd = find_hex(result))) != std::string_view::npos; )
			result.replace(fnd, 3, 1, ((result[fnd + 1] & 0xf) + (result[fnd + 1] >> 6) * 9) << 4
				| ((result[fnd + 2] & 0xf) + (result[fnd + 2] >> 6) * 9));
		return result;
	}
	static constexpr std::string_view get_name(component what)
	{
		if (what < countof)
			return component_names[what];
		throw(std::out_of_range("invalid component index"));
	}

	friend std::ostream& operator<<(std::ostream& os, const basic_uri& what)
	{
		os << std::setw(12) << std::left << "source" << what._source << '\n';
		for (component ii{}; ii != countof; ii = component(ii + 1))
			if (what.test(ii))
				os << std::setw(12) << std::left << what.get_name(ii)
					<< (what.get_component(ii).size() ? what.get_component(ii) : "(empty)") << '\n';
		return os;
	}
};

//-----------------------------------------------------------------------------------------
class uri_storage
{
protected:
	std::string _buffer;
	constexpr uri_storage(std::string src) noexcept : _buffer(std::move(src)) {}
	constexpr uri_storage() = delete;
	~uri_storage() = default;
};

//-----------------------------------------------------------------------------------------
class uri : private uri_storage, public basic_uri
{
public:
	constexpr uri(std::string src, bool decode=true)
		: uri_storage(decode && uri::has_hex(src) ? uri::decode_hex(src) : std::move(src)), basic_uri(_buffer) {}
	constexpr uri() = default;
	~uri() = default;

	constexpr std::string replace(std::string src)
	{
		auto rbuf { std::exchange(_buffer, std::move(src)) };
		assign(_buffer);
		return rbuf;
	}
	constexpr const std::string& get_buffer() const noexcept { return _buffer; }
};

} // FIX8
#endif // FIX8_URI_HPP_
